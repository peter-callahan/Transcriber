<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Organizer & OCR</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .upload-area { border: 2px dashed #ddd; border-radius: 8px; padding: 40px; text-align: center; margin: 20px 0; background: white; }
        .upload-area.dragover { border-color: #007bff; background: #f8f9fa; }
        .upload-area.uploading { border-color: #28a745; background: #d4edda; }

        /* Upload Progress Styles */
        .upload-progress { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: none; }
        .upload-progress-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center; color: #28a745; }
        .upload-progress-bar-track { background: #f0f0f0; border-radius: 10px; height: 20px; position: relative; overflow: hidden; margin: 15px 0; }
        .upload-progress-bar-fill { background: linear-gradient(90deg, #28a745, #20c997); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px; }
        .upload-progress-percentage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #333; font-size: 12px; }
        .upload-file-status { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin: 15px 0; }
        .upload-file-item { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #eee; }
        .upload-file-item:last-child { border-bottom: none; }
        .upload-file-name { flex: 1; font-size: 14px; color: #333; }
        .upload-file-status-badge { padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; }
        .status-waiting { background: #f8f9fa; color: #6c757d; }
        .status-uploading { background: #cce7ff; color: #0066cc; }
        .status-success { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
        .upload-controls { text-align: center; margin-top: 15px; }
        .upload-cancel-btn { background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; }
        .upload-cancel-btn:hover { background: #c82333; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; font-size: 14px; }
        .btn:hover { background: #0056b3; }
        .btn-danger { background: #dc3545; }
        .btn-danger:hover { background: #c82333; }
        .btn-success { background: #28a745; }
        .btn-success:hover { background: #218838; }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #5a6268; }

        /* Removed old uploaded-images class - now using .images-section */

        /* Main content layout with CSS Grid - Desktop only */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 20px;
            margin: 20px 0;
        }
        .images-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        .groups-sidebar {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            position: sticky;
            top: 20px;
        }

        .images-container { display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0; }
        .image-item { position: relative; border: 2px solid transparent; border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.2s; }
        .image-item:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .image-item:hover .preview-btn { opacity: 1; }
        .image-item.selected { border-color: #007bff; }
        .image-item img { width: 120px; height: 120px; object-fit: contain; display: block; background: #f5f5f5; }
        .image-item .checkbox { position: absolute; top: 5px; right: 5px; }
        .image-item .group-badge { position: absolute; top: 5px; left: 5px; background: #007bff; color: white; padding: 2px 6px; border-radius: 10px; font-size: 12px; }
        .image-item .preview-btn { position: absolute; bottom: 5px; right: 5px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; opacity: 0; transition: opacity 0.2s; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        .image-item .preview-btn:hover { background: rgba(0,0,0,0.9); }

        /* View and Sort Controls */
        .view-controls { display: flex; align-items: center; }
        .view-btn { padding: 6px 12px; margin: 0 2px; }
        .view-btn.active { background: #007bff; color: white; }
        .sort-select { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; background: white; }

        /* List View Styles */
        .images-container.list-view { flex-direction: column; gap: 0; }
        .image-item.list-view {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 1px;
            border-radius: 0;
            width: 100%;
            transform: none;
        }
        .image-item.list-view:first-child { border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .image-item.list-view:last-child { border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; margin-bottom: 0; }
        .image-item.list-view:hover { transform: none; background: #f8f9fa; }
        .image-item.list-view img {
            width: 60px;
            height: 60px;
            margin-right: 15px;
            border-radius: 4px;
            object-fit: contain;
            background: #f5f5f5;
        }
        .image-item.list-view .image-info {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .image-item.list-view .image-name {
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }
        .image-item.list-view .image-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .image-item.list-view .checkbox {
            position: static;
            margin: 0;
        }
        .image-item.list-view .group-badge {
            position: static;
            margin-left: 10px;
        }
        .image-item.list-view .preview-btn {
            position: static;
            opacity: 1;
            margin-left: 5px;
        }

        /* Groups sidebar styling */
        .groups-section { margin: 0; padding: 0; background: transparent; box-shadow: none; }
        .groups-list { display: flex; flex-direction: column; gap: 15px; margin: 15px 0; }
        .group-card { border: 2px solid #ddd; border-radius: 8px; padding: 15px; width: 100%; min-height: 100px; }
        .group-card.drag-over { border-color: #28a745; background: #d4edda; }
        .group-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
        .group-name { font-weight: bold; font-size: 14px; line-height: 1.2; }
        .group-count { color: #666; font-size: 12px; white-space: nowrap; }
        .group-images { display: flex; flex-wrap: wrap; gap: 4px; }
        .group-images .group-image-container { position: relative; }
        .group-images img { width: 32px; height: 32px; object-fit: contain; border-radius: 3px; background: #f8f9fa; }
        .group-image-remove { position: absolute; top: -2px; right: -2px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 14px; height: 14px; font-size: 10px; cursor: pointer; display: none; line-height: 1; padding: 0; }
        .group-image-container:hover .group-image-remove { display: block; }
        .group-image-remove:hover { background: #c82333; }
        .group-header-controls { display: flex; flex-direction: column; gap: 5px; align-items: flex-end; }
        .group-delete-btn { padding: 2px 6px; font-size: 12px; }

        /* Filter controls styling */
        .filter-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; }
        .filter-controls label { font-size: 14px; color: #333; cursor: pointer; display: flex; align-items: center; gap: 6px; }
        .filter-controls input[type="checkbox"] { margin: 0; }

        .image-item.dragging { opacity: 0.5; transform: rotate(5deg); }
        .batch-group-creation { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .group-input-row { display: flex; align-items: center; gap: 10px; margin: 5px 0; }
        .group-input-row input { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .group-input-row button { padding: 6px 12px; }

        .controls { text-align: center; margin: 20px 0; }
        .controls input { padding: 8px; margin: 0 10px; border: 1px solid #ddd; border-radius: 4px; }

        .processing-status { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 15px; border-radius: 4px; margin: 20px 0; }
        .processing-status.success { background: #d4edda; border-color: #c3e6cb; color: #155724; }
        .processing-status.error { background: #f8d7da; border-color: #f5c6cb; color: #721c24; }

        .config-section { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .form-group { margin: 10px 0; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }

        .hidden { display: none; }

        /* Modal styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; z-index: 1000; }
        .modal-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; padding: 20px; min-width: 300px; max-width: 500px; }
        .modal-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; }
        .modal-body { margin-bottom: 20px; }
        .modal-footer { display: flex; gap: 10px; justify-content: flex-end; }

        /* Image preview modal */
        .image-preview-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 1001; cursor: pointer; }
        .image-preview-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .image-preview-content img {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: zoom-in;
        }
        .image-preview-content img.actual-size {
            max-width: none;
            max-height: none;
            cursor: grab;
        }
        .image-preview-content img.actual-size:active {
            cursor: grabbing;
        }
        .image-preview-close { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center; z-index: 1002; }
        .image-preview-close:hover { background: rgba(255,255,255,0.3); }
        .image-preview-nav { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 24px; display: flex; align-items: center; justify-content: center; z-index: 1002; transition: all 0.2s; }
        .image-preview-nav:hover { background: rgba(255,255,255,0.4); transform: translateY(-50%) scale(1.1); }
        .image-preview-nav:disabled { opacity: 0.3; cursor: not-allowed; }
        .image-preview-nav:disabled:hover { background: rgba(255,255,255,0.2); transform: translateY(-50%); }
        .image-preview-prev { left: 20px; }
        .image-preview-next { right: 20px; }
        .image-preview-title { position: absolute; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 4px; font-size: 14px; }
        .image-preview-counter { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 4px; font-size: 14px; }

        /* Progress bar styles */
        .progress-container { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: none; }
        .progress-header { font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center; }
        .progress-bar-track { background: #f0f0f0; border-radius: 10px; height: 20px; position: relative; overflow: hidden; }
        .progress-bar-fill { background: linear-gradient(90deg, #007bff, #28a745); height: 100%; width: 0%; transition: width 0.5s ease-in-out; border-radius: 10px; position: relative; }
        .progress-bar-fill::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); animation: shimmer 2s infinite; }
        @keyframes shimmer { 0% { left: -100%; } 100% { left: 100%; } }
        .progress-percentage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #333; font-size: 12px; }
        .progress-steps { display: flex; justify-content: space-between; margin-top: 15px; }
        .progress-step { text-align: center; flex: 1; padding: 0 5px; }
        .progress-step-icon { width: 30px; height: 30px; border-radius: 50%; background: #ddd; color: #666; display: flex; align-items: center; justify-content: center; margin: 0 auto 8px; font-size: 16px; transition: all 0.3s; }
        .progress-step.active .progress-step-icon { background: #007bff; color: white; }
        .progress-step.completed .progress-step-icon { background: #28a745; color: white; }
        .progress-step-label { font-size: 12px; color: #666; }
        .progress-step.active .progress-step-label { color: #007bff; font-weight: bold; }
        .progress-step.completed .progress-step-label { color: #28a745; }

        /* Inline editing styles */
        .group-name-editable { cursor: pointer; padding: 2px 4px; border-radius: 4px; }
        .group-name-editable:hover { background: #f0f0f0; }
        .group-name-input { border: 2px solid #007bff; padding: 2px 4px; border-radius: 4px; font-weight: bold; font-size: 16px; }
        .edit-name-btn { font-size: 12px; padding: 2px 6px; margin-left: 5px; }

        /* Desktop-only app - no mobile styles needed */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Photo Organizer & OCR</h1>
            <p>Upload photos, group them visually, then process with OCR and AI transcription</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-area" id="uploadArea">
            <div>
                <h3>Drop photos here or click to select</h3>
                <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
                <button class="btn" onclick="event.stopPropagation(); document.getElementById('fileInput').click()">Choose Files</button>
            </div>
        </div>

        <!-- Upload Progress Section -->
        <div class="upload-progress" id="uploadProgress">
            <div class="upload-progress-header" id="uploadProgressHeader">Uploading files...</div>
            <div class="upload-progress-bar-track">
                <div class="upload-progress-bar-fill" id="uploadProgressBarFill"></div>
                <div class="upload-progress-percentage" id="uploadProgressPercentage">0%</div>
            </div>
            <div id="uploadProgressStatus">Preparing upload...</div>
            <div class="upload-file-status" id="uploadFileStatus"></div>
            <div class="upload-controls">
                <button class="upload-cancel-btn" onclick="cancelUpload()" id="uploadCancelBtn">Cancel Upload</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content" id="mainContent">
            <!-- Images Section -->
            <div class="images-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>Uploaded Images</h3>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="view-controls">
                            <span style="font-size: 14px; margin-right: 8px;">View:</span>
                            <button class="btn btn-secondary view-btn active" onclick="toggleView('grid')" id="gridViewBtn">⊞ Grid</button>
                            <button class="btn btn-secondary view-btn" onclick="toggleView('list')" id="listViewBtn">☰ List</button>
                        </div>
                        <div class="sort-controls">
                            <span style="font-size: 14px; margin-right: 8px;">Sort:</span>
                            <select class="sort-select" onchange="sortImages(this.value)" id="sortSelect">
                                <option value="upload">Upload Order</option>
                                <option value="name-asc">Name A-Z</option>
                                <option value="name-desc">Name Z-A</option>
                            </select>
                        </div>
                        <div>
                            <button class="btn btn-secondary" onclick="selectAll()">Select All</button>
                            <button class="btn btn-secondary" onclick="selectNone()">Select None</button>
                            <button class="btn btn-danger" onclick="clearAllImages()">Clear All</button>
                        </div>
                    </div>
                </div>

                <!-- Filter Controls -->
                <div class="filter-controls" id="filterControls" style="display: none;">
                    <label>
                        <input type="checkbox" id="hideGroupedFilter" onchange="toggleGroupedFilter()">
                        Hide grouped images
                    </label>
                    <span style="color: #666; font-size: 13px;" id="filterStatus">Showing all images</span>
                </div>

                <div class="images-container" id="imagesContainer">
                    <div style="text-align: center; color: #666; font-style: italic; padding: 40px;">
                        No images uploaded yet. Use the upload area above to get started.
                    </div>
                </div>
            </div>

            <!-- Groups Sidebar -->
            <div class="groups-sidebar">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Groups</h3>
                    <div>
                        <button class="btn" style="padding: 6px 10px; font-size: 12px;" onclick="addSingleGroup()">+ Add Group</button>
                    </div>
                </div>

                <!-- Group Creation Controls -->
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;" onclick="createSingleGroup()">Put All Images in One Group</button>
                    <button class="btn btn-secondary" style="width: 100%;" onclick="showBatchGroupCreation()">Create Multiple Groups</button>
                </div>

                <!-- Batch Group Creation -->
                <div class="batch-group-creation" id="batchGroupCreation" style="display: none;">
                    <h4 style="font-size: 14px;">Create Multiple Groups</h4>
                    <div id="groupInputsList">
                        <div class="group-input-row">
                            <input type="text" placeholder="Group name" class="group-name-input">
                            <button class="btn btn-danger" onclick="removeGroupInput(this)">Remove</button>
                        </div>
                    </div>
                    <div style="text-align: center; margin: 15px 0;">
                        <button class="btn btn-secondary" onclick="addGroupInput()">Add Another Group</button>
                        <button class="btn btn-success" onclick="createMultipleGroups()">Create All Groups</button>
                        <button class="btn" onclick="hideBatchGroupCreation()">Cancel</button>
                    </div>
                </div>

                <!-- Groups List -->
                <div class="groups-section" id="groupsSection">
                    <div class="groups-list" id="groupsList"></div>
                    <div style="text-align: center; margin-top: 15px;">
                        <button class="btn btn-danger" onclick="clearAllGroups()" style="font-size: 12px; padding: 6px 12px;">Clear All Groups</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Processing Section -->
        <div class="controls">
            <button class="btn btn-success" onclick="processGroups()" style="font-size: 18px; padding: 15px 30px;">
                🚀 Process All Groups
            </button>
        </div>

        <!-- Progress Bar -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-header" id="progressHeader">Processing Groups...</div>
            <div class="progress-bar-track">
                <div class="progress-bar-fill" id="progressBarFill"></div>
                <div class="progress-percentage" id="progressPercentage">0%</div>
            </div>
            <div class="progress-steps">
                <div class="progress-step" id="step1">
                    <div class="progress-step-icon">📁</div>
                    <div class="progress-step-label">Organizing</div>
                </div>
                <div class="progress-step" id="step2">
                    <div class="progress-step-icon">🖼️</div>
                    <div class="progress-step-label">Processing Images</div>
                </div>
                <div class="progress-step" id="step3">
                    <div class="progress-step-icon">👁️</div>
                    <div class="progress-step-label">OCR Extraction</div>
                </div>
                <div class="progress-step" id="step4">
                    <div class="progress-step-icon">🤖</div>
                    <div class="progress-step-label">AI Processing</div>
                </div>
                <div class="progress-step" id="step5">
                    <div class="progress-step-icon">✅</div>
                    <div class="progress-step-label">Complete</div>
                </div>
            </div>
        </div>

        <!-- Status Section -->
        <div id="statusSection"></div>

        <!-- Configuration -->
        <div class="config-section">
            <h3>Configuration</h3>
            <div class="form-group">
                <label>Output Folder:</label>
                <input type="text" id="outputFolder" value="./markdown_output">
            </div>
            <button class="btn" onclick="updateConfig()">Update Config</button>
        </div>
    </div>

    <!-- Modal Dialog -->
    <div class="modal-overlay" id="modalOverlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header" id="modalHeader">Confirm</div>
            <div class="modal-body" id="modalBody">Are you sure?</div>
            <div class="modal-footer" id="modalFooter">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-danger" onclick="confirmModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="image-preview-overlay" id="imagePreviewOverlay" onclick="closeImagePreview()">
        <button class="image-preview-close" onclick="closeImagePreview()">×</button>
        <button class="image-preview-nav image-preview-prev" id="previewPrevBtn" onclick="event.stopPropagation(); navigatePreview(-1)">‹</button>
        <button class="image-preview-nav image-preview-next" id="previewNextBtn" onclick="event.stopPropagation(); navigatePreview(1)">›</button>
        <div class="image-preview-content" onclick="event.stopPropagation()">
            <img id="previewImage" src="" alt="" ondblclick="toggleImageSize()" title="Double-click to toggle actual size">
            <div class="image-preview-title" id="previewTitle"></div>
            <div class="image-preview-counter" id="previewCounter"></div>
        </div>
    </div>

    <script>
        let uploadedImages = [];
        let imageGroups = [];
        let currentView = 'grid';
        let currentSort = 'upload';
        let uploadQueue = [];
        let isUploading = false;
        let uploadCancelled = false;
        let currentUploadController = null;
        let currentPreviewIndex = -1;
        let currentPreviewGroupIndex = -1;
        let currentPreviewGroupImages = [];
        let displayedImages = []; // Tracks the currently displayed/sorted images
        let hideGrouped = false; // Filter to hide grouped images
        const BATCH_SIZE = 8; // Upload 8 files at a time
        const MAX_RETRIES = 3;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadConfig();
            setupUploadHandlers();
            loadViewPreferences();
        });

        function setupUploadHandlers() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // Drag and drop
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });

            // File input change
            fileInput.addEventListener('change', function(e) {
                handleFiles(e.target.files);
            });

            // Click to open file dialog
            uploadArea.addEventListener('click', function(e) {
                // Don't trigger if clicking on the button or its contents
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    return;
                }
                fileInput.click();
            });
        }

        function handleFiles(files) {
            if (isUploading) {
                showModal('Upload in Progress', 'Please wait for the current upload to complete', 'OK', false);
                return;
            }

            // Reset file input to allow re-selecting same files
            document.getElementById('fileInput').value = '';

            // Prepare upload queue
            uploadQueue = [];
            for (let i = 0; i < files.length; i++) {
                uploadQueue.push({
                    file: files[i],
                    name: files[i].name,
                    status: 'waiting',
                    retries: 0,
                    error: null
                });
            }

            if (uploadQueue.length === 0) return;

            startBatchUpload();
        }

        async function startBatchUpload() {
            isUploading = true;
            uploadCancelled = false;

            // Show progress UI
            showUploadProgress();
            document.getElementById('uploadArea').classList.add('uploading');

            // Initialize file status display
            updateFileStatusDisplay();

            try {
                const totalFiles = uploadQueue.length;
                let completedFiles = 0;

                // Process files in batches
                for (let i = 0; i < uploadQueue.length; i += BATCH_SIZE) {
                    if (uploadCancelled) break;

                    const batch = uploadQueue.slice(i, i + BATCH_SIZE);
                    const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
                    const totalBatches = Math.ceil(uploadQueue.length / BATCH_SIZE);

                    updateUploadProgress(completedFiles, totalFiles, `Processing batch ${batchNumber} of ${totalBatches}...`);

                    // Upload batch
                    await uploadBatch(batch);

                    completedFiles = uploadQueue.filter(item => item.status === 'success').length;
                    updateUploadProgress(completedFiles, totalFiles, `Completed ${completedFiles} of ${totalFiles} files`);
                }

                // Handle completion
                const successCount = uploadQueue.filter(item => item.status === 'success').length;
                const errorCount = uploadQueue.filter(item => item.status === 'error').length;

                if (uploadCancelled) {
                    updateUploadProgress(successCount, totalFiles, 'Upload cancelled');
                } else if (errorCount === 0) {
                    updateUploadProgress(totalFiles, totalFiles, `All ${totalFiles} files uploaded successfully!`);
                } else {
                    updateUploadProgress(successCount, totalFiles, `${successCount} files uploaded, ${errorCount} failed`);
                }

                // Process successful uploads
                if (successCount > 0) {
                    const successfulFiles = uploadQueue.filter(item => item.status === 'success' && item.responseData);
                    if (successfulFiles.length > 0) {
                        const newFiles = successfulFiles.flatMap(item =>
                            item.responseData.files?.map(f => ({...f, selected: false, groupId: null})) || []
                        );
                        uploadedImages = [...uploadedImages, ...newFiles];
                        displayImages();
                        // Main content is always visible now
                    }
                }

                // Auto-hide progress after delay
                setTimeout(() => {
                    hideUploadProgress();
                }, 3000);

            } catch (error) {
                console.error('Upload process error:', error);
                updateUploadProgress(0, uploadQueue.length, 'Upload process failed');
            } finally {
                isUploading = false;
                document.getElementById('uploadArea').classList.remove('uploading');
            }
        }

        async function uploadBatch(batch) {
            const promises = batch.map(item => uploadSingleFile(item));
            await Promise.allSettled(promises);
        }

        async function uploadSingleFile(item, retryCount = 0) {
            if (uploadCancelled || item.status === 'success') return;

            item.status = 'uploading';
            updateFileStatusDisplay();

            try {
                currentUploadController = new AbortController();
                const formData = new FormData();
                formData.append('files', item.file);

                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData,
                    signal: currentUploadController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error && !data.files) {
                    throw new Error(data.error);
                }

                // Handle partial success (HTTP 207)
                if (response.status === 207) {
                    item.status = 'success';
                    item.responseData = data;
                    item.error = null;
                    item.warnings = data.errors || [];
                } else if (data.uploaded_count > 0) {
                    item.status = 'success';
                    item.responseData = data;
                    item.error = null;
                } else {
                    throw new Error(data.errors ? data.errors.join(', ') : 'Upload failed');
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    item.status = 'cancelled';
                    return;
                }

                console.error(`Upload failed for ${item.name}:`, error);
                item.retries++;
                item.error = error.message;

                if (item.retries < MAX_RETRIES && !uploadCancelled) {
                    // Retry with exponential backoff
                    const delay = Math.min(1000 * Math.pow(2, item.retries - 1), 5000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return uploadSingleFile(item, retryCount + 1);
                } else {
                    item.status = 'error';
                }
            }

            updateFileStatusDisplay();
        }

        function displayImages() {
            const container = document.getElementById('imagesContainer');
            container.innerHTML = '';

            // Show/hide filter controls based on whether we have images
            if (uploadedImages.length > 0) {
                document.getElementById('filterControls').style.display = 'flex';
            } else {
                document.getElementById('filterControls').style.display = 'none';
                container.innerHTML = '<div style="text-align: center; color: #666; font-style: italic; padding: 40px;">No images uploaded yet. Use the upload area above to get started.</div>';
                return;
            }

            // Apply filtering
            let filteredImages = [...uploadedImages];
            if (hideGrouped) {
                filteredImages = filteredImages.filter(img => img.groupId === null);
            }

            // Apply sorting
            displayedImages = [...filteredImages];
            if (currentSort === 'name-asc') {
                displayedImages.sort((a, b) => a.name.localeCompare(b.name));
            } else if (currentSort === 'name-desc') {
                displayedImages.sort((a, b) => b.name.localeCompare(a.name));
            }
            // 'upload' keeps original order

            // Update filter status
            updateFilterStatus();

            // Apply view class to container
            container.className = `images-container ${currentView === 'list' ? 'list-view' : ''}`;

            displayedImages.forEach((image, displayIndex) => {
                const originalIndex = uploadedImages.indexOf(image);
                const div = document.createElement('div');
                div.className = `image-item ${currentView === 'list' ? 'list-view' : ''} ${image.selected ? 'selected' : ''}`;
                div.draggable = true;
                div.dataset.imageIndex = originalIndex;
                div.dataset.displayIndex = displayIndex;

                if (currentView === 'list') {
                    div.innerHTML = `
                        <img src="${image.path}" alt="${image.name}" onclick="event.stopPropagation(); showImagePreview(${displayIndex})" style="cursor: pointer;">
                        <div class="image-info">
                            <div class="image-name">${image.name}</div>
                            <div class="image-controls">
                                ${image.groupId !== null ? `<div class="group-badge">G${image.groupId + 1}</div>` : ''}
                                <input type="checkbox" class="checkbox" ${image.selected ? 'checked' : ''}
                                       onchange="event.stopPropagation(); toggleImageSelection(${originalIndex})">
                            </div>
                        </div>
                    `;
                } else {
                    div.innerHTML = `
                        <img src="${image.path}" alt="${image.name}" onclick="event.stopPropagation(); showImagePreview(${displayIndex})" style="cursor: pointer;">
                        <input type="checkbox" class="checkbox" ${image.selected ? 'checked' : ''}
                               onchange="event.stopPropagation(); toggleImageSelection(${originalIndex})">
                        ${image.groupId !== null ? `<div class="group-badge">G${image.groupId + 1}</div>` : ''}
                    `;
                }

                div.onclick = (e) => {
                    if (e.target.type !== 'checkbox' && e.target.tagName !== 'IMG') {
                        toggleImageSelection(originalIndex);
                    }
                };

                // Add drag event listeners
                div.addEventListener('dragstart', handleImageDragStart);
                div.addEventListener('dragend', handleImageDragEnd);

                container.appendChild(div);
            });
        }

        function toggleImageSelection(index) {
            uploadedImages[index].selected = !uploadedImages[index].selected;
            displayImages();
        }

        function selectAll() {
            uploadedImages.forEach(img => img.selected = true);
            displayImages();
        }

        function selectNone() {
            uploadedImages.forEach(img => img.selected = false);
            displayImages();
        }

        function getSelectedImages() {
            return uploadedImages.filter(img => img.selected);
        }

        function createSingleGroup() {
            if (uploadedImages.length === 0) {
                showModal('No Images', 'Please upload images first', 'OK', false);
                return;
            }

            const groupName = `Group ${imageGroups.length + 1}`;
            const newGroup = {
                id: imageGroups.length,
                name: groupName,
                images: uploadedImages.map(img => img.name)
            };

            // Update all image group assignments
            uploadedImages.forEach((img, index) => {
                uploadedImages[index].groupId = newGroup.id;
                uploadedImages[index].selected = false;
            });

            imageGroups.push(newGroup);

            displayImages();
            displayGroups();
            showSection('groupsSection');
        }


        function displayGroups() {
            const container = document.getElementById('groupsList');
            container.innerHTML = '';

            imageGroups.forEach((group, index) => {
                const div = document.createElement('div');
                div.className = 'group-card';
                div.dataset.groupIndex = index;
                div.innerHTML = `
                    <div class="group-header">
                        <div style="flex: 1;">
                            <span class="group-name group-name-editable" onclick="startEditGroupName(${index})" id="groupName${index}">${group.name}</span>
                        </div>
                        <div class="group-header-controls">
                            <span class="group-count">${group.images.length} images</span>
                            <div>
                                <button class="btn btn-secondary edit-name-btn" onclick="startEditGroupName(${index})" style="padding: 2px 6px; font-size: 12px;">✏️</button>
                                <button class="btn btn-danger group-delete-btn" onclick="deleteGroup(${index})">×</button>
                            </div>
                        </div>
                    </div>
                    <div class="group-images">
                        ${group.images.map(imgName => {
                            const img = uploadedImages.find(ui => ui.name === imgName);
                            return img ? `
                                <div class="group-image-container">
                                    <img src="${img.path}" alt="${imgName}" title="${imgName}" onclick="showGroupImagePreview(${index}, '${imgName}')" style="cursor: pointer;">
                                    <button class="group-image-remove" onclick="removeFromGroup('${imgName}', ${index})" title="Remove from group">×</button>
                                </div>
                            ` : '';
                        }).join('')}
                    </div>
                `;

                // Add drop event listeners to groups
                div.addEventListener('dragover', handleGroupDragOver);
                div.addEventListener('dragleave', handleGroupDragLeave);
                div.addEventListener('drop', handleGroupDrop);

                container.appendChild(div);
            });

            // Show groups section if there are groups
            if (imageGroups.length > 0) {
                showSection('groupsSection');
            } else {
                hideSection('groupsSection');
            }
        }


        async function deleteGroup(groupId) {
            const confirmed = await showModal('Delete Group', `Delete ${imageGroups[groupId].name}?`, 'Delete', true);
            if (!confirmed) return;

            // Remove group assignment from images
            uploadedImages.forEach(img => {
                if (img.groupId === groupId) {
                    img.groupId = null;
                } else if (img.groupId > groupId) {
                    img.groupId -= 1;
                }
            });

            imageGroups.splice(groupId, 1);

            // Update group IDs
            imageGroups.forEach((group, index) => {
                group.id = index;
            });

            displayImages();
            displayGroups();

            if (imageGroups.length === 0) {
                hideSection('groupsSection');
            }
        }

        function removeFromGroup(imageName, groupId) {
            // Find the image and remove it from the group
            const img = uploadedImages.find(img => img.name === imageName);
            if (img) {
                img.groupId = null;

                // Remove image from the group's images array
                const group = imageGroups[groupId];
                if (group) {
                    group.images = group.images.filter(name => name !== imageName);
                }

                // Refresh displays
                displayImages();
                displayGroups();
            }
        }

        async function clearAllImages() {
            const confirmed = await showModal('Clear All Images', 'Clear all uploaded images?', 'Clear', true);
            if (!confirmed) return;

            fetch('/api/clear_temp', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                uploadedImages = [];
                imageGroups = [];
                // Main content stays visible - just clear the images
                showStatus('All images cleared', 'success');
            })
            .catch(error => {
                console.error('Clear error:', error);
                showStatus('Failed to clear images', 'error');
            });
        }

        async function clearAllGroups() {
            const confirmed = await showModal('Clear All Groups', 'Clear all groups? (Images will remain uploaded)', 'Clear', true);
            if (!confirmed) return;

            uploadedImages.forEach(img => {
                img.groupId = null;
                img.selected = false;
            });
            imageGroups = [];

            displayImages();
            displayGroups();
        }

        function processGroups() {
            if (imageGroups.length === 0) {
                showModal('No Groups', 'Please create at least one group before processing', 'OK', false);
                return;
            }

            processWithProgress();
        }

        function loadConfig() {
            fetch('/api/config')
            .then(response => response.json())
            .then(data => {
                document.getElementById('outputFolder').value = data.output_folder || './markdown_output';
            })
            .catch(error => {
                console.error('Load config error:', error);
            });
        }

        function updateConfig() {
            const config = {
                output_folder: document.getElementById('outputFolder').value
            };

            fetch('/api/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                showStatus('Configuration updated', 'success');
            })
            .catch(error => {
                console.error('Update config error:', error);
                showStatus('Failed to update configuration', 'error');
            });
        }

        function showSection(sectionId) {
            document.getElementById(sectionId).style.display = 'block';
        }

        function hideSection(sectionId) {
            document.getElementById(sectionId).style.display = 'none';
        }

        function showStatus(message, type = 'info', persist = false) {
            const statusSection = document.getElementById('statusSection');
            statusSection.innerHTML = `<div class="processing-status ${type}">${message}</div>`;

            // Auto-hide after 5 seconds for success messages, unless persist is true
            if (type === 'success' && !persist) {
                setTimeout(() => {
                    statusSection.innerHTML = '';
                }, 5000);
            }
        }

        // Batch group creation functions
        function showBatchGroupCreation() {
            const container = document.getElementById('groupInputsList');
            // Default to 2 groups
            container.innerHTML = `
                <div class="group-input-row">
                    <input type="text" placeholder="Group name" class="group-name-input" value="Group ${imageGroups.length + 1}">
                    <button class="btn btn-danger" onclick="removeGroupInput(this)">Remove</button>
                </div>
                <div class="group-input-row">
                    <input type="text" placeholder="Group name" class="group-name-input" value="Group ${imageGroups.length + 2}">
                    <button class="btn btn-danger" onclick="removeGroupInput(this)">Remove</button>
                </div>
            `;
            document.getElementById('batchGroupCreation').style.display = 'block';
        }

        function hideBatchGroupCreation() {
            document.getElementById('batchGroupCreation').style.display = 'none';
            // Reset to single input
            const container = document.getElementById('groupInputsList');
            container.innerHTML = `
                <div class="group-input-row">
                    <input type="text" placeholder="Group name" class="group-name-input">
                    <button class="btn btn-danger" onclick="removeGroupInput(this)">Remove</button>
                </div>
            `;
        }

        function addGroupInput() {
            const container = document.getElementById('groupInputsList');
            const nextGroupNumber = imageGroups.length + container.children.length + 1;
            const div = document.createElement('div');
            div.className = 'group-input-row';
            div.innerHTML = `
                <input type="text" placeholder="Group name" class="group-name-input" value="Group ${nextGroupNumber}">
                <button class="btn btn-danger" onclick="removeGroupInput(this)">Remove</button>
            `;
            container.appendChild(div);
        }

        function removeGroupInput(button) {
            const container = document.getElementById('groupInputsList');
            if (container.children.length > 1) {
                button.parentElement.remove();
            } else {
                showModal('Cannot Remove', 'At least one group is required', 'OK', false);
            }
        }

        function createMultipleGroups() {
            const inputs = document.querySelectorAll('.group-name-input');
            const groupNames = Array.from(inputs).map(input => input.value.trim()).filter(name => name);

            if (groupNames.length === 0) {
                showModal('No Group Names', 'Please enter at least one group name', 'OK', false);
                return;
            }

            // Check for duplicate names
            const uniqueNames = [...new Set(groupNames)];
            if (uniqueNames.length !== groupNames.length) {
                showModal('Duplicate Names', 'Group names must be unique', 'OK', false);
                return;
            }

            // Create all groups
            groupNames.forEach(name => {
                const newGroup = {
                    id: imageGroups.length,
                    name: name,
                    images: []
                };
                imageGroups.push(newGroup);
            });

            displayGroups();
            showSection('groupsSection');
            hideBatchGroupCreation();
            showStatus(`Created ${groupNames.length} groups`, 'success');
        }

        // Drag and drop functions
        let draggedImageIndex = null;

        function handleImageDragStart(e) {
            draggedImageIndex = parseInt(e.target.closest('.image-item').dataset.imageIndex);
            e.target.closest('.image-item').classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleImageDragEnd(e) {
            e.target.closest('.image-item').classList.remove('dragging');
            draggedImageIndex = null;
        }


        function handleGroupDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('drag-over');
        }

        function handleGroupDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleGroupDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedImageIndex === null) return;

            const groupIndex = parseInt(e.currentTarget.dataset.groupIndex);
            const image = uploadedImages[draggedImageIndex];

            // Remove image from current group if it's in one
            if (image.groupId !== null) {
                const currentGroup = imageGroups[image.groupId];
                const imgIndex = currentGroup.images.indexOf(image.name);
                if (imgIndex > -1) {
                    currentGroup.images.splice(imgIndex, 1);
                }
            }

            // Add image to new group
            image.groupId = groupIndex;
            if (!imageGroups[groupIndex].images.includes(image.name)) {
                imageGroups[groupIndex].images.push(image.name);
            }

            displayImages();
            displayGroups();
            showStatus(`Moved image to ${imageGroups[groupIndex].name}`, 'success');
        }

        // Single group creation function
        function addSingleGroup() {
            const groupName = `Group ${imageGroups.length + 1}`;

            const newGroup = {
                id: imageGroups.length,
                name: groupName,
                images: []
            };

            imageGroups.push(newGroup);
            displayGroups();
            showStatus(`Created "${groupName}"`, 'success');
        }

        // Inline group name editing
        function startEditGroupName(groupIndex) {
            const nameSpan = document.getElementById(`groupName${groupIndex}`);
            const currentName = imageGroups[groupIndex].name;

            // Replace span with input
            nameSpan.innerHTML = `<input type="text" class="group-name-input" value="${currentName}"
                                 onblur="finishEditGroupName(${groupIndex}, this)"
                                 onkeypress="if(event.key==='Enter') finishEditGroupName(${groupIndex}, this)"
                                 id="editInput${groupIndex}">`;

            // Focus and select the input
            const input = document.getElementById(`editInput${groupIndex}`);
            input.focus();
            input.select();
        }

        function finishEditGroupName(groupIndex, inputElement) {
            const newName = inputElement.value.trim();
            const nameSpan = document.getElementById(`groupName${groupIndex}`);

            if (newName && newName !== imageGroups[groupIndex].name) {
                // Check for duplicate names
                if (imageGroups.some((group, idx) => idx !== groupIndex && group.name === newName)) {
                    showStatus('A group with this name already exists', 'error');
                    // Restore original name
                    nameSpan.textContent = imageGroups[groupIndex].name;
                    return;
                }

                // Update the group name
                imageGroups[groupIndex].name = newName;
                showStatus(`Renamed to "${newName}"`, 'success');
            }

            // Restore the span
            nameSpan.textContent = imageGroups[groupIndex].name;
            nameSpan.className = 'group-name group-name-editable';
            nameSpan.onclick = () => startEditGroupName(groupIndex);
        }

        // Modal functions
        let modalCallback = null;

        function showModal(title, message, confirmText = 'OK', isConfirm = true) {
            return new Promise((resolve) => {
                document.getElementById('modalHeader').textContent = title;
                document.getElementById('modalBody').textContent = message;

                const footer = document.getElementById('modalFooter');
                if (isConfirm) {
                    footer.innerHTML = `
                        <button class="btn btn-secondary" onclick="closeModal(false)">Cancel</button>
                        <button class="btn btn-danger" onclick="closeModal(true)">${confirmText}</button>
                    `;
                } else {
                    footer.innerHTML = `
                        <button class="btn" onclick="closeModal(true)">OK</button>
                    `;
                }

                modalCallback = resolve;
                document.getElementById('modalOverlay').style.display = 'block';
            });
        }

        function closeModal(result = false) {
            document.getElementById('modalOverlay').style.display = 'none';
            if (modalCallback) {
                modalCallback(result);
                modalCallback = null;
            }
        }

        // Image preview functions
        function showImagePreview(displayIndex) {
            if (displayIndex < 0 || displayIndex >= displayedImages.length) return;

            currentPreviewIndex = displayIndex;
            const image = displayedImages[displayIndex];

            // Always use processed image (what gets sent to APIs)
            let imageUrl;
            let titleSuffix;
            if (image.groupId !== null && image.groupId !== undefined) {
                // Use processed image from input folder
                const groupName = `n${image.groupId + 1}`;
                imageUrl = `/api/processed/${groupName}/${image.name}`;
                titleSuffix = ` (Group ${image.groupId + 1} - Server Version)`;
            } else {
                // For ungrouped images, still show what would be processed
                imageUrl = `/api/processed/temp/${image.name}`;
                titleSuffix = ' (Server Version)';
            }

            document.getElementById('previewImage').src = imageUrl;
            document.getElementById('previewTitle').textContent = image.name + titleSuffix;
            document.getElementById('previewCounter').textContent = `${displayIndex + 1} of ${displayedImages.length}`;

            // Update navigation buttons
            updatePreviewNavigation();

            document.getElementById('imagePreviewOverlay').style.display = 'block';
        }

        function navigatePreview(direction) {
            const newIndex = currentPreviewIndex + direction;

            // Check if we're in group preview mode
            if (currentPreviewGroupIndex >= 0 && currentPreviewGroupImages.length > 0) {
                // Navigate within the current group
                if (newIndex >= 0 && newIndex < currentPreviewGroupImages.length) {
                    const imageName = currentPreviewGroupImages[newIndex];
                    showGroupImagePreview(currentPreviewGroupIndex, imageName);
                }
            } else {
                // Navigate within the main image list
                if (newIndex >= 0 && newIndex < displayedImages.length) {
                    showImagePreview(newIndex);
                }
            }
        }

        function updatePreviewNavigation() {
            const prevBtn = document.getElementById('previewPrevBtn');
            const nextBtn = document.getElementById('previewNextBtn');

            prevBtn.disabled = currentPreviewIndex <= 0;
            nextBtn.disabled = currentPreviewIndex >= displayedImages.length - 1;

            // Hide buttons if there's only one image
            if (displayedImages.length <= 1) {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            } else {
                prevBtn.style.display = 'flex';
                nextBtn.style.display = 'flex';
            }
        }

        function showGroupImagePreview(groupIndex, imageName) {
            const group = imageGroups[groupIndex];
            if (!group || !group.images.includes(imageName)) return;

            // Set up group preview context
            currentPreviewGroupIndex = groupIndex;
            currentPreviewGroupImages = group.images.slice(); // Copy array
            const imageIndex = group.images.indexOf(imageName);

            if (imageIndex === -1) return;

            currentPreviewIndex = imageIndex;
            const image = uploadedImages.find(img => img.name === imageName);
            if (!image) return;

            // Use processed image from group folder
            const groupName = `n${groupIndex + 1}`;
            const imageUrl = `/api/processed/${groupName}/${imageName}`;
            const titleSuffix = ` (Group ${groupIndex + 1} - Server Version)`;

            document.getElementById('previewImage').src = imageUrl;
            document.getElementById('previewTitle').textContent = imageName + titleSuffix;
            document.getElementById('previewCounter').textContent = `${imageIndex + 1} of ${group.images.length} in ${group.name}`;

            // Update navigation buttons for group context
            updateGroupPreviewNavigation();

            document.getElementById('imagePreviewOverlay').style.display = 'block';
        }

        function closeImagePreview() {
            document.getElementById('imagePreviewOverlay').style.display = 'none';
            currentPreviewIndex = -1;
            currentPreviewGroupIndex = -1;
            currentPreviewGroupImages = [];
            // Reset image size when closing
            document.getElementById('previewImage').classList.remove('actual-size');
        }

        function toggleImageSize() {
            const img = document.getElementById('previewImage');
            img.classList.toggle('actual-size');

            // Reset transform when toggling back to fit mode
            if (!img.classList.contains('actual-size')) {
                img.style.transform = '';
            }
        }

        function updateGroupPreviewNavigation() {
            const prevBtn = document.getElementById('previewPrevBtn');
            const nextBtn = document.getElementById('previewNextBtn');

            prevBtn.disabled = currentPreviewIndex <= 0;
            nextBtn.disabled = currentPreviewIndex >= currentPreviewGroupImages.length - 1;

            // Hide buttons if there's only one image
            if (currentPreviewGroupImages.length <= 1) {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            } else {
                prevBtn.style.display = 'flex';
                nextBtn.style.display = 'flex';
            }
        }

        // Pan functionality for actual-size images
        let isPanning = false;
        let startX, startY, scrollLeft, scrollTop;

        document.getElementById('previewImage').addEventListener('mousedown', function(e) {
            if (!this.classList.contains('actual-size')) return;

            isPanning = true;
            this.style.cursor = 'grabbing';
            startX = e.pageX - (this.offsetLeft || 0);
            startY = e.pageY - (this.offsetTop || 0);

            // Get current transform values
            const transform = this.style.transform;
            const matrix = transform.match(/translate\(([^,]+),([^)]+)\)/);
            scrollLeft = matrix ? parseFloat(matrix[1]) : 0;
            scrollTop = matrix ? parseFloat(matrix[2]) : 0;
        });

        document.getElementById('previewImage').addEventListener('mouseleave', function() {
            isPanning = false;
            if (this.classList.contains('actual-size')) {
                this.style.cursor = 'zoom-out';
            }
        });

        document.getElementById('previewImage').addEventListener('mouseup', function() {
            isPanning = false;
            if (this.classList.contains('actual-size')) {
                this.style.cursor = 'zoom-out';
            }
        });

        document.getElementById('previewImage').addEventListener('mousemove', function(e) {
            if (!isPanning || !this.classList.contains('actual-size')) return;

            e.preventDefault();
            const x = e.pageX - (this.offsetLeft || 0);
            const y = e.pageY - (this.offsetTop || 0);
            const walkX = (x - startX);
            const walkY = (y - startY);

            this.style.transform = `translate(${scrollLeft + walkX}px, ${scrollTop + walkY}px)`;
        });

        // Keyboard navigation for preview
        document.addEventListener('keydown', function(event) {
            const overlay = document.getElementById('imagePreviewOverlay');
            if (overlay.style.display === 'block') {
                switch(event.key) {
                    case 'Escape':
                        event.preventDefault();
                        closeImagePreview();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        navigatePreview(-1);
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        navigatePreview(1);
                        break;
                }
            }
        });

        // Progress bar functions
        function showProgressBar() {
            document.getElementById('progressContainer').style.display = 'block';
            resetProgress();
        }

        function hideProgressBar() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        function resetProgress() {
            document.getElementById('progressBarFill').style.width = '0%';
            document.getElementById('progressPercentage').textContent = '0%';

            // Reset all steps
            for (let i = 1; i <= 5; i++) {
                const step = document.getElementById(`step${i}`);
                step.classList.remove('active', 'completed');
            }
        }

        function updateProgress(step, percentage, message) {
            // Update progress bar
            document.getElementById('progressBarFill').style.width = percentage + '%';
            document.getElementById('progressPercentage').textContent = percentage + '%';
            document.getElementById('progressHeader').textContent = message;

            // Update step indicators
            for (let i = 1; i <= 5; i++) {
                const stepElement = document.getElementById(`step${i}`);
                stepElement.classList.remove('active', 'completed');

                if (i < step) {
                    stepElement.classList.add('completed');
                } else if (i === step) {
                    stepElement.classList.add('active');
                }
            }
        }

        function updateProgressFromServer(progress) {
            // Update progress bar with server data
            document.getElementById('progressBarFill').style.width = progress.percentage + '%';

            // Create detailed message and percentage display
            let message = progress.current_step;
            let percentageText = progress.percentage + '%';

            if (progress.status === 'processing' && progress.total_groups > 0) {
                message = `Group ${progress.current_group}/${progress.total_groups}: ${progress.current_step}`;
                // Add completed groups info to percentage
                if (progress.completed_groups > 0) {
                    percentageText = `${progress.percentage}% (${progress.completed_groups}/${progress.total_groups} groups completed)`;
                }
            }

            document.getElementById('progressHeader').textContent = message;
            document.getElementById('progressPercentage').textContent = percentageText;

            // Map server progress to steps
            let step = 1;
            if (progress.current_step.includes('Resizing')) step = 2;
            else if (progress.current_step.includes('OCR')) step = 3;
            else if (progress.current_step.includes('Converting')) step = 4;
            else if (progress.current_step.includes('Exporting') || progress.current_step.includes('complete')) step = 5;

            // Update step indicators
            for (let i = 1; i <= 5; i++) {
                const stepElement = document.getElementById(`step${i}`);
                stepElement.classList.remove('active', 'completed');

                if (i < step) {
                    stepElement.classList.add('completed');
                } else if (i === step) {
                    stepElement.classList.add('active');
                }
            }
        }

        async function processWithProgress() {
            showProgressBar();
            let progressPolling;

            try {
                // Start progress polling
                updateProgress(1, 0, 'Starting processing...');

                progressPolling = setInterval(async () => {
                    try {
                        const progressResponse = await fetch('/api/progress');
                        const progress = await progressResponse.json();
                        updateProgressFromServer(progress);
                    } catch (e) {
                        console.error('Failed to fetch progress:', e);
                    }
                }, 1000); // Poll every second

                // Send the processing request
                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ groups: imageGroups })
                });

                // Stop polling when request completes
                clearInterval(progressPolling);

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                // Get the final result
                const data = await response.json();

                // Final update
                updateProgress(5, 100, 'Processing complete!');
                await new Promise(resolve => setTimeout(resolve, 500));

                if (data.message) {
                    showStatus(data.message, 'success', true); // persist = true
                    // Clear everything after successful processing
                    uploadedImages = [];
                    imageGroups = [];
                    displayImages();
                    displayGroups();

                    // Hide progress bar after a delay
                    setTimeout(() => {
                        hideProgressBar();
                    }, 2000);
                } else if (data.error) {
                    throw new Error(data.error);
                }

            } catch (error) {
                // Stop polling on error
                if (progressPolling) {
                    clearInterval(progressPolling);
                }
                console.error('Process error:', error);
                showStatus(`Processing failed: ${error.message}`, 'error');
                hideProgressBar();
            }
        }

        // Upload Progress Functions
        function showUploadProgress() {
            document.getElementById('uploadProgress').style.display = 'block';
        }

        function hideUploadProgress() {
            document.getElementById('uploadProgress').style.display = 'none';
        }

        function updateUploadProgress(completed, total, statusText) {
            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            document.getElementById('uploadProgressBarFill').style.width = percentage + '%';
            document.getElementById('uploadProgressPercentage').textContent = percentage + '%';
            document.getElementById('uploadProgressStatus').textContent = statusText;
            document.getElementById('uploadProgressHeader').textContent = `Uploading files... (${completed}/${total})`;
        }

        function updateFileStatusDisplay() {
            const statusContainer = document.getElementById('uploadFileStatus');
            statusContainer.innerHTML = '';

            uploadQueue.forEach(item => {
                const div = document.createElement('div');
                div.className = 'upload-file-item';

                const statusClass = `status-${item.status}`;
                let statusText = item.status.charAt(0).toUpperCase() + item.status.slice(1);
                if (item.status === 'error' && item.error) {
                    statusText += ` (${item.retries}/${MAX_RETRIES})`;
                } else if (item.status === 'success' && item.warnings && item.warnings.length > 0) {
                    statusText += ' (with warnings)';
                }

                let tooltip = '';
                if (item.error) {
                    tooltip = `title="${item.error}"`;
                } else if (item.warnings && item.warnings.length > 0) {
                    tooltip = `title="${item.warnings.join('; ')}"`;
                }

                div.innerHTML = `
                    <span class="upload-file-name">${item.name}</span>
                    <span class="upload-file-status-badge ${statusClass}" ${tooltip}>${statusText}</span>
                `;

                statusContainer.appendChild(div);
            });
        }

        function cancelUpload() {
            if (!isUploading) return;

            uploadCancelled = true;
            if (currentUploadController) {
                currentUploadController.abort();
            }

            document.getElementById('uploadProgressStatus').textContent = 'Cancelling upload...';
            document.getElementById('uploadCancelBtn').disabled = true;
            document.getElementById('uploadCancelBtn').textContent = 'Cancelling...';

            setTimeout(() => {
                document.getElementById('uploadCancelBtn').disabled = false;
                document.getElementById('uploadCancelBtn').textContent = 'Cancel Upload';
            }, 2000);
        }

        // Filter Functions
        function toggleGroupedFilter() {
            hideGrouped = document.getElementById('hideGroupedFilter').checked;
            localStorage.setItem('hideGrouped', hideGrouped);
            displayImages();
        }

        function updateFilterStatus() {
            const total = uploadedImages.length;
            const displayed = displayedImages.length;
            const grouped = uploadedImages.filter(img => img.groupId !== null).length;
            const ungrouped = total - grouped;

            let statusText = `Showing ${displayed} of ${total} images`;
            if (hideGrouped && ungrouped > 0) {
                statusText += ` (${ungrouped} ungrouped)`;
            } else if (total > 0) {
                statusText += ` (${grouped} grouped, ${ungrouped} ungrouped)`;
            }

            document.getElementById('filterStatus').textContent = statusText;
        }

        // View and Sort Functions
        function toggleView(viewType) {
            currentView = viewType;

            // Update button states
            document.getElementById('gridViewBtn').classList.toggle('active', viewType === 'grid');
            document.getElementById('listViewBtn').classList.toggle('active', viewType === 'list');

            // Save preference
            localStorage.setItem('imageView', viewType);

            // Refresh display
            displayImages();
        }

        function sortImages(sortType) {
            currentSort = sortType;

            // Save preference
            localStorage.setItem('imageSort', sortType);

            // Refresh display
            displayImages();
        }

        function loadViewPreferences() {
            // Load saved view preference
            const savedView = localStorage.getItem('imageView');
            if (savedView && (savedView === 'grid' || savedView === 'list')) {
                currentView = savedView;
                document.getElementById('gridViewBtn').classList.toggle('active', savedView === 'grid');
                document.getElementById('listViewBtn').classList.toggle('active', savedView === 'list');
            }

            // Load saved sort preference
            const savedSort = localStorage.getItem('imageSort');
            if (savedSort && ['upload', 'name-asc', 'name-desc'].includes(savedSort)) {
                currentSort = savedSort;
                document.getElementById('sortSelect').value = savedSort;
            }

            // Load saved filter preference
            const savedFilter = localStorage.getItem('hideGrouped');
            if (savedFilter !== null) {
                hideGrouped = savedFilter === 'true';
                document.getElementById('hideGroupedFilter').checked = hideGrouped;
            }
        }
    </script>
</body>
</html>